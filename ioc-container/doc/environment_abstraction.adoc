= Environment Abstraction
:sourcedir: ../src/main/java
:resourcedir: ../src/main/resources
:docudir: ..
:toc:
:sectnumlevels: 5


Das Environment Interface ist eine in den Container integrierte Abstraktion, die zwei wichtige Aspekte der Anwendungsumgebung modelliert:

* Profile
* Properties

== 1.13.1 Bean Definition Profiles

Profile werden im Spring IoC Container verwendet umd verschiedene Bean Definitionen in verschiedenen Environments zu registrieren. Environment kann dabei verschiedene Vorstellungen hervorrufen wie

* Unterschiedliche DataSource Konfiguration für verschiedene Stages/Laufzeitstufen
* InMemory Konfigurationen wie Datenbanken oder Security
* Mandantenspezifische Konfigurationen zur Unterscheidung von Mandant A zu Mandant B Deployments
* und weitere mehr

=== @Profile

Beim Profile
link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/profile/ProfileRunner.java[ProfileRunner.java] starten wir 2 verschiedene Kontexte mit unterschiedlichen Profilen.

[source,java]
----
public class ProfileRunner {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.getEnvironment().setActiveProfiles("aprofile");
        context.register(AppConfig.class);
        context.refresh();

        List<String> beans = Arrays.stream(context.getBeanDefinitionNames())
                .filter(bean -> !bean.contains("org.springframework")
                        && !bean.contains("appConfig"))
                .collect(Collectors.toList());
        Assertions.assertThat(beans)
                .hasSize(2)
                .containsExactly("AConfiguration", "springBean");

        SpringBean bean = context.getBean(SpringBean.class);
        bean.sayHello();
        context.close();


        AnnotationConfigApplicationContext contextB = new AnnotationConfigApplicationContext();
        contextB.getEnvironment().setActiveProfiles("bprofile");
        contextB.register(AppConfig.class);
        contextB.refresh();

        List<String> beansB = Arrays.stream(contextB.getBeanDefinitionNames())
                .filter(beanB -> !beanB.contains("org.springframework")
                        && !beanB.contains("appConfig"))
                .collect(Collectors.toList());
        Assertions.assertThat(beansB)
                .hasSize(2)
                .containsExactly("BConfiguration", "springBean");

        SpringBean beanB = contextB.getBean(SpringBean.class);
        beanB.sayHello();
        contextB.close();
    }
}
----

Die beiden A- und link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/profile/config/AConfiguration.java[BConfiguration.java] Klassen sind mit @Profile annotiert, hier am Beispiel der Klasse link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/profile/config/AConfiguration.java[AConfiguration.java].

[source,java]
----
@Profile("aprofile")
@Configuration
public class AConfiguration {

    @Bean
    public SpringBean springBean () {
        return new SpringBeanA();
    }
}
----

Der String im @Profile kann wie im Beispiel einen einfachen Ausdruck besitzen, oder aber einen kompliziertere Logik verwenden. Folgende Operatoren können für die ProfilAusdrücke verwendet werden.

* *!*: A logical “not” of the profile
* *&*: A logical “and” of the profiles
* *|*: A logical “or” of the profiles

[IMPORTANT]
====
Die Operatoren *&* und *|* können nicht gemischt werden, ohne Klammern zu verwenden.

Z.B. ist folgender Ausdruck nicht zulässig: "production & us-east | eu-central", sondern muss folgendermassen geschrieben werden: "production & (us-east | eu-central)"
====

[IMPORTANT]
====
Wenn eine @Configuration-Klasse mit @Profile markiert ist, werden alle @Bean-Methoden und @Import-Annotationen, die mit dieser Klasse verbunden sind, umgangen, sofern nicht eines oder mehrere der angegebenen Profile aktiv sind. Wenn eine @Komponenten- oder @Konfigurationsklasse mit @Profile({"p1", "p2"}) markiert ist, wird diese Klasse nicht registriert oder verarbeitet, es sei denn, die Profile "p1" oder "p2" wurden aktiviert. Wird einem bestimmten Profil der Operator NOT (!) vorangestellt, wird das kommentierte Element nur registriert, wenn das Profil nicht aktiv ist. Wird beispielsweise @Profile({"p1", "!p2"}) angegeben, erfolgt die Registrierung, wenn das Profil "p1" aktiv ist oder wenn das Profil "p2" nicht aktiv ist.
====
Dazu ein Beispiel:

Im Package src/main/java/ch/wesr/spring/core/container/annotation/environment/multipleprofiles gibt es folgende mit @Configuration und @Profile annotierte Klassen.

* link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/multipleprofiles/config/AConfiguration.java[AConfiguration.java] mit der @Profile({"aprofile", "!cprofile"}) Annotation
* link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/multipleprofiles/config/BConfiguration.java[BConfiguration.java] mit der @Profile({"bprofile", "!aprofile"}) Annotation
* link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/multipleprofiles/config/CConfiguration.java[CConfiguration.java] mit der @Profile({"cprofile", "!aprofile"}) Annotation



Im link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/multipleprofiles/ProfileRunner.java[ProfileRunner.java] werden 2 Profile (*aprofile* und *cprofile*) auf aktiv gesetzt.

[source,java]
----
public class ProfileRunner {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.getEnvironment().setActiveProfiles("aprofile", "cprofile");

        context.register(AppConfig.class);
        context.refresh();

        List<String> beans = Arrays.stream(context.getBeanDefinitionNames())
                .filter(bean -> !bean.contains("org.springframework")
                        && !bean.contains("appConfig"))
                .collect(Collectors.toList());
        Assertions.assertThat(beans)
                .hasSize(4)
                .containsExactly("AConfiguration", "CConfiguration", "springBean", "springBeanB");

        SpringBean bean = (SpringBean) context.getBean("springBean");
        bean.sayHello();

        SpringBean beanB = (SpringBean) context.getBean("springBeanB");
        beanB.sayHello();
        context.close();
    }
}
----


==== @Profile auf Methodenebene
@Profile kann auch auf Methodenebene deklariert werden, um nur eine bestimmte Bean einer Konfigurationsklasse einzuschließen (z. B. für alternative Varianten einer bestimmten Bean), wie das folgende Beispiel zeigt:

link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/profileonmethod/ProfileRunner.java[ProfileRunner.java]

[source, java]
----
public class ProfileRunner {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.getEnvironment().setActiveProfiles("aprofile", "bprofile");
        // wichtig ist, dass die activeProfiles zuerst gesetzt werden und erst dann die AppConfig.class registriert wird.
        context.register(AppConfig.class);
        context.refresh();

        List<String> beans = Arrays.stream(context.getBeanDefinitionNames())
                .filter(bean -> !bean.contains("org.springframework")
                        && !bean.contains("appConfig"))
                .collect(Collectors.toList());
        Assertions.assertThat(beans)
                .hasSize(2)
                .containsExactly("springBean", "springBeanB");

        SpringBean bean = (SpringBean) context.getBean("springBean");
        bean.sayHello();

        SpringBean beanB = (SpringBean) context.getBean("springBeanB");
        beanB.sayHello();

        context.close();
    }
}
----

In der
link:{sourcedir}/ch/wesr/spring/core/container/annotation/environment/profileonmethod/AppConfig.java[AppConfig.java] werden dann auf den Bean Methoden die Profiile definiert.

[source,java]
----
@Configuration
@ComponentScan(basePackages = {"ch.wesr.spring.core.container.annotation.environment.profileonmethod", "ch.wesr.spring.core.container.annotation.environment.beans"})
public class AppConfig {

    @Bean
    @Profile("aprofile")
    public SpringBean springBean() {
        return new SpringBeanA();
    }

    @Bean
    @Profile("bprofile")
    public SpringBean springBeanB() {
        return new SpringBeanB();
    }
}
----



und der profile Aufruf mit maven ebenfalls hier dokumentieren

== Referenzen
* https://mkyong.com/spring/spring-profiles-example/

